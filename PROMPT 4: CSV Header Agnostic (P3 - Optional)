Cline, support different CSV column names/orders.

**Problem:** Legacy CSVs use different column names

**Task:** Parse CSV by header names, not position

**File to modify:** `src/csv_parser.rs` (or wherever CSV parsing is)

**Changes:**
```rust
pub fn parse_task_csv(csv_content: &str) -> Result<Vec<TaskRecord>, CsvError> {
    let mut reader = csv::ReaderBuilder::new()
        .has_headers(true)
        .from_reader(csv_content.as_bytes());
    
    let headers = reader.headers()?.clone();
    
    // Find column indices (supports multiple names)
    let zap_id_idx = find_column(&headers, &["zap_id", "id"])?;
    let status_idx = find_column(&headers, &["status", "result", "state"])?;
    let started_idx = find_column(&headers, &["started_at", "timestamp", "created_at"])?;
    let error_idx = find_column(&headers, &["error_message", "error", "failure_reason"]).ok();
    
    let mut records = Vec::new();
    for result in reader.records() {
        let record = result?;
        
        records.push(TaskRecord {
            zap_id: record[zap_id_idx].parse().unwrap_or(0),
            status: record[status_idx].to_string(),
            started_at: record[started_idx].to_string(),
            error_message: error_idx.map(|idx| record[idx].to_string()),
        });
    }
    
    Ok(records)
}

fn find_column(
    headers: &csv::StringRecord, 
    candidates: &[&str]
) -> Result<usize, CsvError> {
    headers.iter()
        .position(|h| {
            let h_lower = h.to_lowercase();
            candidates.iter().any(|c| h_lower == c.to_lowercase())
        })
        .ok_or_else(|| CsvError::MissingColumn(candidates[0].to_string()))
}
```

**Acceptance:**
- [ ] Parses modern CSV (status, started_at, error_message)
- [ ] Parses legacy CSV (result, timestamp, error)
- [ ] All tests still pass

Run full test suite.
```

---

## E) FINAL ANSWER

### ✅ **ÁNOTÁCIA:**

**Incremental approach je CORRECT.**

**Sequence:**
```
Step 0: Generate test fixtures (I'll create ZIPs)
Step 1: Create test harness (Prompt 0)
Step 2: Fix flexible paths (Prompt 1)
Step 3: Fix serde aliases (Prompt 2)
Step 4: Fix partial mode (Prompt 3)
Step 5: Fix CSV headers (Prompt 4 - optional)